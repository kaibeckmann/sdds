.#  ===========================================================================
.#  Generate linux implementation
.#
.#  This is a code generator built using the iMatix GSL code generation
.#  language. See https://github.com/imatix/gsl for details.
.#
.#  This script will generate the following files:
.#      * sdds linux implementation
.#  ===========================================================================
.#
.#  Generate sDDS implementation header
.#
.if !file.exists ("$(project.name)_sdds_impl.h")
.echo "Generating $(project.name)_sdds_impl.h ..."
.output "$(project.name)_sdds_impl.h"
/*  =========================================================================
    $(project.name:) - $(project.description:)

.       for project.license
    $(string.trim (license.):block                                         )
.       endfor

$(project.GENERATED_WARNING_HEADER:)
    =========================================================================
*/
#ifndef $(PROJECT.NAME)_SDDS_IMPL_H_INC
#define $(PROJECT.NAME)_SDDS_IMPL_H_INC

.for project.topic
#include "$(topic.c_name)-ds.h"
.endfor

.for project.topic
extern DDS_DataReader g_$(topic.c_name:)_reader;
extern DDS_DataWriter g_$(topic.c_name:)_writer;
extern DDS_Topic g_$(topic.c_name:)_topic;

.endfor
#endif
/*
$(project.GENERATED_WARNING_HEADER:)
*/
.close
.endif
.#
.#  Generate sDDS implementation source
.#
.if !file.exists ("$(project.name)_sdds_impl.c")
.echo "Generating $(project.name)_sdds_impl.c ..."
.output "$(project.name)_sdds_impl.c"
/*  =========================================================================
    $(project.name:) - $(project.description:)

.       for project.license
    $(string.trim (license.):block                                         )
.       endfor

$(project.GENERATED_WARNING_HEADER:)
    =========================================================================
*/
#include "$(project.name)_sdds_impl.h"
.if project.os = "autobest"
.   if autobest_role = "server"
#include <hv_error.h>
.   endif
.endif

DDS_ReturnCode_t DDS_DataReader_set_listener(
	DDS_DataReader self,
	const struct DDS_DataReaderListener* a_listener,
	const DDS_StatusMask mask
)
{
.if count (project.role, role.type = "subscriber")
	rc_t ret = DataReader_set_on_data_avail_listener((DataReader_t *) self, (On_Data_Avail_Listener) a_listener->on_data_available, (const StatusMask) mask);
	if (ret == SDDS_RT_OK)
		return DDS_RETCODE_OK;
.endif
	return DDS_RETCODE_ERROR;
}

.for project.topic
DDS_Topic g_$(topic.c_name:)_topic;
$(topic.c_name:) g_$(topic.c_name:)_pool[SDDS_TOPIC_APP_MSG_COUNT];
.   if count (project.role, role.topic = topic.name & role.type = "subscriber")
DDS_DataReader g_$(topic.c_name:)_reader;
.   endif
.   if count (project.role, role.topic = topic.name & role.type = "publisher")
DDS_DataWriter g_$(topic.c_name:)_writer;
.   endif

.endfor
rc_t
sDDS_init (void)
{
    rc_t ret = SDDS_RT_OK;
    //  Initializes all sDDS classes is defined in sDDS.c
    //  Must be first as all other classes depend on it
.# Additional inits for the autobest sdds server
.if project.os = "autobest"
.   if autobest_role = "server"
    // init shms
    assert(shm_server_init() == E_OK);
.   endif
.endif
	assert(TaskMng_init() == SDDS_RT_OK);
    assert(BitArray_init() == SDDS_RT_OK);
    // Initalize classes
    assert(Memory_init() == SDDS_RT_OK);
	assert(LocatorDB_init() == SDDS_RT_OK);
	assert(DataSource_init() == SDDS_RT_OK);
	assert(DataSink_init() == SDDS_RT_OK);
	assert(sdds_History_init() == SDDS_RT_OK);
	assert(Network_init() == SDDS_RT_OK);
#ifdef FEATURE_SDDS_BUILTIN_TOPICS_ENABLED
	assert(BuiltinTopic_init() == SDDS_RT_OK);
#endif
#ifdef FEATURE_SDDS_DISCOVERY_ENABLED
	assert(Discovery_init() == SDDS_RT_OK);
#endif
#ifdef FEATURE_SDDS_TRACEING_ENABLED
    assert(Trace_init() == SDDS_RT_OK);
#endif

    assert(LocatorDB_freeLocators() > 0);

    Locator_t* locator;
.for project.topic
    $(topic.c_name:)_init ();
    g_$(topic.c_name:)_topic = sDDS_$(topic.c_name:)Topic_create(g_$(topic.c_name:)_pool, SDDS_TOPIC_APP_MSG_COUNT);
    assert(g_$(topic.c_name:)_topic != NULL);
.   if count (project.role, role.topic = topic.name & role.type = "subscriber")
    g_$(topic.c_name:)_reader = DataSink_create_datareader(g_$(topic.c_name:)_topic, NULL, NULL, NULL);
.       if defined (topic.history_depth)
    sdds_History_setup (DataReader_history (g_$(topic.c_name:)_reader), $(topic.c_name)_samples_pool, $(topic.history_depth));
.       else
    sdds_History_setup (DataReader_history (g_$(topic.c_name:)_reader), $(topic.c_name)_samples_pool, SDDS_QOS_HISTORY_DEPTH);
.       endif
.   endif
.   if count (project.role, role.topic = topic.name & role.type = "publisher")
    g_$(topic.c_name:)_writer = DataSource_create_datawriter(g_$(topic.c_name:)_topic, NULL, NULL, NULL);
.      if project.qos_reliability_has_kind_reliableAck | project.qos_reliability_has_kind_reliableNack
.       endif

.   endif

.   for project.role where topic.name = role.topic
.       for role.subscriber
    ret = LocatorDB_newLocator (&locator);
    if (ret != SDDS_RT_OK)
        return ret;

    Locator_upRef (locator);

.   if defined (subscriber.port)
    ret = Network_set_locator_endpoint (locator, "$(subscriber.ip)", $(subscriber.port));
.   else
    ret = Network_setAddressToLocator (locator, "$(subscriber.ip)");
.   endif
    if (ret != SDDS_RT_OK)
        return ret;

    ret = Topic_addRemoteDataSink (g_$(topic.c_name:)_topic, locator);
    if (ret != SDDS_RT_OK)
        return ret;

    Locator_downRef (locator);
.       endfor
.   endfor
.endfor
    return ret;
}
/*
$(project.GENERATED_WARNING_HEADER:)
*/
.close
.endif
