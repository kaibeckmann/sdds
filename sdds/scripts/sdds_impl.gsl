.#  ===========================================================================
.#  Generate linux implementation
.#
.#  This is a code generator built using the iMatix GSL code generation
.#  language. See https://github.com/imatix/gsl for details.
.#
.#  This script will generate the following files:
.#      * sdds linux implementation
.#  ===========================================================================
.#
.#  Generate sDDS implementation header
.#
.echo "Generating $(project.name)_sdds_impl.h ..."
.output "$(project.name)_sdds_impl.h"
/*  =========================================================================
    $(project.name:) - $(project.description:)

.       for project.license
    $(string.trim (license.):block                                         )
.       endfor

$(project.GENERATED_WARNING_HEADER:)
    =========================================================================
*/
#ifndef $(PROJECT.NAME)_SDDS_IMPL_H_INC
#define $(PROJECT.NAME)_SDDS_IMPL_H_INC

#include "gen_constants.h"

#include <dds/DDS_DCPS.h>
#include <os-ssal/Memory.h>
#include <os-ssal/NodeConfig.h>
#include <sdds/DataSink.h>
#include <sdds/DataSource.h>
#include <sdds/LocatorDB.h>
#include <sdds/Log.h>
#include <sdds/Network.h>
#include <sdds/sDDS.h>
#ifdef FEATURE_SDDS_DISCOVERY_ENABLED
#include <sdds/Discovery.h>
#endif
#ifdef FEATURE_SDDS_BUILTIN_TOPICS_ENABLED
#include <sdds/BuiltinTopic.h>
#endif

.for project.topic
#include "$(topic.c_name)-ds.h"
.endfor

.for project.topic
extern DDS_DataReader g_$(topic.c_name:)_reader;
extern DDS_DataWriter g_$(topic.c_name:)_writer;
extern DDS_Topic g_$(topic.c_name:)_topic;

.endfor
#endif
/*
$(project.GENERATED_WARNING_HEADER:)
*/
.close
.#
.#  Generate sDDS implementation source
.#
.echo "Generating $(project.name)_sdds_impl.c ..."
.output "$(project.name)_sdds_impl.c"
/*  =========================================================================
    $(project.name:) - $(project.description:)

.       for project.license
    $(string.trim (license.):block                                         )
.       endfor

$(project.GENERATED_WARNING_HEADER:)
    =========================================================================
*/
#include "$(project.name)_sdds_impl.h"

DDS_ReturnCode_t DDS_DataReader_set_listener(
	DDS_DataReader self,
	const struct DDS_DataReaderListener* a_listener,
	const DDS_StatusMask mask
)
{
.if count (project.role, role.type = "subscriber")
	rc_t ret = DataReader_set_on_data_avail_listener((DataReader_t *) self, (On_Data_Avail_Listener) a_listener->on_data_available, (const StatusMask) mask);
	if (ret == SDDS_RT_OK)
		return DDS_RETCODE_OK;
.endif
	return DDS_RETCODE_ERROR;
}

.for project.topic
DDS_Topic g_$(topic.c_name:)_topic;
$(topic.c_name:) g_$(topic.c_name:)_pool[SDDS_TOPIC_APP_MSG_COUNT];
.   if count (project.role, role.topic = topic.name & role.type = "subscriber")
DDS_DataReader g_$(topic.c_name:)_reader;
.   endif
.   if count (project.role, role.topic = topic.name & role.type = "publisher")
DDS_DataWriter g_$(topic.c_name:)_writer;
.   endif

.endfor
rc_t
sDDS_init (void)
{
    rc_t ret;
    //  Initializes all sDDS classes is defined in sDDS.c
    //  Must be first as all other classes depend on it
    if (BitArray_init () == SDDS_RT_FAIL) {
        return SDDS_RT_FAIL;
    }
    // Initalize classes
    ret = Memory_init ();
    if (ret == SDDS_RT_FAIL) goto exit;
	ret = LocatorDB_init ();
    if (ret == SDDS_RT_FAIL) goto exit;
	ret = DataSource_init ();
    if (ret == SDDS_RT_FAIL) goto exit;
	ret = DataSink_init ();
    if (ret == SDDS_RT_FAIL) goto exit;
	ret = Network_init ();
    if (ret == SDDS_RT_FAIL) goto exit;
#ifdef FEATURE_SDDS_BUILTIN_TOPICS_ENABLED
	ret = BuiltinTopic_init ();
    if (ret == SDDS_RT_FAIL) goto exit;
#endif
#ifdef FEATURE_SDDS_DISCOVERY_ENABLED
	ret = Discovery_init ();
    if (ret == SDDS_RT_FAIL) goto exit;
#endif

	Locator_t* l;
.for project.topic
    g_$(topic.c_name:)_topic = sDDS_$(topic.c_name:)Topic_create(g_$(topic.c_name:)_pool, SDDS_TOPIC_APP_MSG_COUNT);
.   if count (project.role, role.topic = topic.name & role.type = "subscriber")
    g_$(topic.c_name:)_reader = DataSink_create_datareader(g_$(topic.c_name:)_topic, NULL, NULL /*&sdds_listener*/, NULL);
.   endif
.   if count (project.role, role.topic = topic.name & role.type = "publisher")
    g_$(topic.c_name:)_writer = DataSource_create_datawriter(g_$(topic.c_name:)_topic, NULL, NULL, NULL);
.   endif

.   for project.role where topic.name = role.topic
.       for role.subscriber
    ret = LocatorDB_newLocator (&l);
    if (ret != SDDS_RT_OK)
        return ret;

    Locator_upRef (l);

.   if defined (subscriber.port)
    ret = Network_set_locator_endpoint (l, "$(subscriber.ip)", $(subscriber.port));
.   else
    ret = Network_setAddressToLocator (l, "$(subscriber.ip)");
.   endif
    if (ret != SDDS_RT_OK)
        return ret;

    ret = Topic_addRemoteDataSink (g_$(topic.c_name:)_topic, l);
    if (ret != SDDS_RT_OK)
        return ret;
    Locator_downRef (l);
.       endfor
.   endfor
.endfor

exit:
	return ret;
}
/*
$(project.GENERATED_WARNING_HEADER:)
*/
.close
