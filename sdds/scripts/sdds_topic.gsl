.#  ===========================================================================
.#  Generate topic data structures
.#
.#  This is a code generator built using the iMatix GSL code generation
.#  language. See https://github.com/imatix/gsl for details.
.#
.#  This script will generate the following files:
.#      * ds (source|header)
.#  ===========================================================================
.#
.template 0

.#
.#  Resolve a topics DDS data types to C data types for encoding of data. Also
.#  calculates the total size of a topic.
.#
function resolve_topic_type (topic)
    my.topic.size ?= 0
    my.topic.description ?= "$(string.trim (topic.?""):left)"

    my.topic.c_name = "$(string.substr (my.topic.name, 0, 0):upper)" + "$(string.substr (my.topic.name, 1):Camel)"

    for my.topic.attribute
        attribute.description ?= "$(string.trim (attribute.?""):left)"
        attribute.size ?= 1

        attribute.enc_type ?= ""
        attribute.print_type ?= ""
        if attribute.type = "DDS_short"
            attribute.enc_type = "int16"
            attribute.print_type = "\"PRId16\""
            my.topic.size += 2
        elsif attribute.type = "DDS_long"
            attribute.enc_type = "int32"
            attribute.print_type = "\"PRId32\""
            my.topic.size += 4
        elsif attribute.type = "DDS_long_long"
            attribute.enc_type = "int64"
            attribute.print_type = "\"PRId64\""
            my.topic.size += 8
        elsif attribute.type = "DDS_unsigned_short"
            attribute.enc_type = "uint16"
            attribute.print_type = "\"PRIu16\""
            my.topic.size += 2
        elsif attribute.type = "DDS_unsigned_long"
            attribute.enc_type = "uint32"
            attribute.print_type = "\"PRIu32\""
            my.topic.size += 4
        elsif attribute.type = "DDS_unsigned_long_long"
            attribute.enc_type = "uint64"
            attribute.print_type = "\"PRIu64\""
            my.topic.size += 8
        elsif attribute.type = "DDS_char"
            attribute.enc_type = "int8"
            attribute.print_type = "c"
            my.topic.size += 1
        elsif attribute.type = "DDS_octet"
            attribute.enc_type = "uint8"
            attribute.print_type = "\"PRIu8\""
            my.topic.size += 1
        elsif attribute.type = "DDS_boolean"
            attribute.enc_type = "bool"
            attribute.print_type = "d"
            my.topic.size += 1
        elsif attribute.type = "DDS_string"
            attribute.type = "DDS_char"
            attribute.enc_type = "string"
            attribute.print_type = "s"
            my.topic.size += attribute.size
        else
            echo "E: Invalid type '$(attribute.type)' for attribute '$(attribute.name)' in topic $(topic.name:)"
        endif
    endfor
endfunction

.#
.#  Resolves a topics configuration parameters.
.#
function resolve_topic_config (topic)
    for my.topic.config
        if config.type = "qos_reliability"
            config.seqNrBitSize ?= ""
            config.reliabilityKind ?= ""
            if reliabilitySeqnrSize = "basic"
                config.seqNrBitSize = "4"
                if config.seqNrBitSize > project.qos_reliability_biggest_seqNr_bitsize
                    project.qos_reliability_biggest_seqNr_bitsize = config.seqNrBitSize
                endif
            elsif reliabilitySeqnrSize = "small"
                config.seqNrBitSize = "8"
                if config.seqNrBitSize > project.qos_reliability_biggest_seqNr_bitsize
                    project.qos_reliability_biggest_seqNr_bitsize = config.seqNrBitSize
                endif
            elsif reliabilitySeqnrSize = "big"
                config.seqNrBitSize = "16"
                if config.seqNrBitSize > project.qos_reliability_biggest_seqNr_bitsize
                    project.qos_reliability_biggest_seqNr_bitsize = config.seqNrBitSize
                endif
            elsif reliabilitySeqnrSize = "huge"
                config.seqNrBitSize = "32"
                project.qos_reliability_biggest_seqNr_bitsize = "32"
            endif

            if kind = "besteffort"
                project.qos_reliability_has_kind_besteffort = "1"
                my.topic.qos_reliability_kind = "1"
            elsif kind = "reliable"
                my.topic.qos_reliability_kind = "2"
                my.topic.qos_reliability_max_blocking_time = max_blocking_time
                if max_blocking_time > project.qos_reliability_biggest_max_blocking_time
                    project.qos_reliability_biggest_max_blocking_time = max_blocking_time
                endif
                if confirmationtype = "ack"
                    project.qos_reliability_has_kind_reliableAck = "1"
                    my.topic.qos_reliability_confirmationtype = "1"
                elsif confirmationtype = "nack"
                    project.qos_reliability_has_kind_reliableNack = "1"
                    my.topic.qos_reliability_confirmationtype = "2"
                endif
            endif
        elsif config.type = "qos_history"
            my.topic.history_depth = config.depth
        else
            echo "E: Invalid config '$(config.type)' in topic $(topic.name:)"
        endif
    endfor
endfunction


function resolve_topic_reliable_datareaders (project)
    for project.role
        if role.type = "subscriber"
            project.qos_reliability_additional_reliable_writers = project.qos_reliability_additional_reliable_writers +1

            for topic
                if topic.name = topicname & topic.config.kind = "reliable"
                    project.qos_reliability_additional_reliable_writers = project.qos_reliability_additional_reliable_writers +1
                endif
            endfor

        endif
    endfor
endfunction

project.qos_reliability_has_kind_besteffort ?= "0"
project.qos_reliability_has_kind_reliableAck ?= "0"
project.qos_reliability_has_kind_reliableNack ?= "0"
project.qos_reliability_biggest_seqNr_bitsize ?= "0"
project.qos_reliability_biggest_max_blocking_time ?= "0"
project.qos_reliability_additional_reliable_writers ?= "0"

for project.topic
    resolve_topic_type (topic)
    resolve_topic_config (topic)
    resolve_topic_reliable_datareaders (project)
endfor

.endtemplate
.for project.topic
.#
.#  Generate topic ds header
.#
.   echo "Generating $(topic.c_name)-ds.h ..."
.   output "$(topic.c_name)-ds.h"
/*  =========================================================================
    $(topic.c_name:) - $(topic.description:)

.       for project.license
    $(string.trim (license.):block                                         )
.       endfor

$(project.GENERATED_WARNING_HEADER:)
    =========================================================================
*/
#ifndef $(TOPIC.NAME)_H_INC
#define $(TOPIC.NAME)_H_INC

#include <sdds/sDDS.h>
#include "List.h"

struct $(topic.c_name:)
{
.   for topic.attribute
    /* $(attribute.description:) */
.       if attribute.enc_type = "string"
    $(attribute.type:) $(attribute.name:c)[$(attribute.size + 1)];
.       else
    $(attribute.type:) $(attribute.name:c);
.       endif
.   endfor
};
typedef struct $(topic.c_name:) $(topic.c_name:);


DDS_ReturnCode_t
$(topic.c_name:)_init ();

#ifdef SDDS_TOPIC_HAS_PUB
DDS_ReturnCode_t DDS_$(topic.c_name:)DataReader_take_next_sample(
    DDS_DataReader _this,
    $(topic.c_name:)** values,
    DDS_SampleInfo* sample_info
);

#endif

#ifdef SDDS_TOPIC_HAS_SUB
DDS_ReturnCode_t DDS_$(topic.c_name:)DataWriter_write(
    DDS_DataWriter _this,
    const $(topic.c_name:)* instance_data,
    const DDS_InstanceHandle_t handle
);
#endif

Topic_t * sDDS_$(topic.c_name:)Topic_create($(topic.c_name:)* pool, int count);

#endif
/*
$(project.GENERATED_WARNING_HEADER:)
*/
.close
.#
.#  Generate topic sources
.#
.   echo "Generating $(topic.c_name)-ds.c ..."
.   output "$(topic.c_name)-ds.c"
/*  =========================================================================
    $(topic.c_name:) - $(topic.description:)

.       for project.license
    $(string.trim (license.):block                                         )
.       endfor

$(project.GENERATED_WARNING_HEADER:)
    =========================================================================
*/
#ifdef __cplusplus
extern "C"
{
#endif

#include "$(topic.c_name)-ds.h"

#include <stdio.h>
#include <string.h>

.if project.os = "autobest"
#include <hv.h>
#include <dds_obj_ids.h>
#include <app.id.h>
.if project.autobest_role = "client"
#include "$(project.name:c)_shm.h"
.endif
.endif

#ifdef __cplusplus
}
#endif

#define SDDS_DOMAIN 0x$(topic.domain)
#define SDDS_TOPIC 0x$(topic.id)

.   if project.os <> "autobest" | (defined (project.autobest_role) & project.autobest_role = "server")
.       if defined (topic.history_depth)
Sample_t $(topic.c_name)_samples_pool[$(topic.history_depth)];
static $(topic.c_name:) $(topic.c_name)_sample_data[$(topic.history_depth)];
.       else
Sample_t $(topic.c_name)_samples_pool[SDDS_QOS_HISTORY_DEPTH];
static $(topic.c_name:) $(topic.c_name)_sample_data[SDDS_QOS_HISTORY_DEPTH];
.       endif
.   endif


.if project.os <> "autobest" | (defined (project.autobest_role) & project.autobest_role = "server")
rc_t TopicMarshalling_$(topic.c_name:)_cpy(Data dest, Data source);

DDS_ReturnCode_t
$(topic.c_name:)_init ()
{
   int index;
.   if defined (topic.history_depth)
   for (index = 0; index < $(topic.history_depth); index++) {
.   else
   for (index = 0; index < SDDS_QOS_HISTORY_DEPTH; index++) {
.   endif
      $(topic.c_name)_samples_pool[index].data = &$(topic.c_name)_sample_data[index];
   }
}

#if defined (SDDS_TOPIC_HAS_PUB)

rc_t TopicMarshalling_$(topic.c_name:)_decode(NetBuffRef_t* buffer, Data data, size_t* size);

DDS_ReturnCode_t DDS_$(topic.c_name:)DataReader_take_next_sample(
    DDS_DataReader self,
    $(topic.c_name:)** data_values,
    DDS_SampleInfo* sample_info
)
{
    rc_t ret = DataReader_take_next_sample((DataReader_t *) self, (Data*) data_values, (DataInfo) sample_info);

    if (ret == SDDS_RT_NODATA)
        return DDS_RETCODE_NO_DATA;

    if (ret == SDDS_RT_OK)
        return DDS_RETCODE_OK;

    return DDS_RETCODE_ERROR;
}

#endif

#if defined (SDDS_TOPIC_HAS_SUB) || defined (SDDS_HAS_QOS_RELIABILITY_KIND_RELIABLE_ACK) || defined (SDDS_HAS_QOS_RELIABILITY_KIND_RELIABLE_NACK)

rc_t TopicMarshalling_$(topic.c_name:)_encode(NetBuffRef_t* buffer, Data data, size_t* size);

DDS_ReturnCode_t DDS_$(topic.c_name:)DataWriter_write(
    DDS_DataWriter _this,
    const $(topic.c_name:)* instance_data,
    const DDS_InstanceHandle_t  handle
)
{
	rc_t ret = DataWriter_write((DataWriter_t *) _this, (Data)instance_data, (void*) handle);

	if (ret == SDDS_RT_OK)
		return DDS_RETCODE_OK;

	return DDS_RETCODE_ERROR;
}
#endif

Topic_t * sDDS_$(topic.c_name:)Topic_create($(topic.c_name:)* pool, int count)
{
	Topic_t *topic = TopicDB_createTopic();
    assert (topic!=NULL);
#if defined (SDDS_TOPIC_HAS_SUB) || defined (SDDS_HAS_QOS_RELIABILITY_KIND_RELIABLE_ACK) || defined (SDDS_HAS_QOS_RELIABILITY_KIND_RELIABLE_ACK)
	topic->Data_encode = TopicMarshalling_$(topic.c_name:)_encode;
	topic->dsinks.list = List_initConcurrentLinkedList();
    if(topic->dsinks.list == NULL){
        return NULL;
    }
#endif

#ifdef SDDS_TOPIC_HAS_PUB
	topic->Data_decode = TopicMarshalling_$(topic.c_name:)_decode;
	topic->dsources.list = List_initConcurrentLinkedList();
    if(topic->dsources.list == NULL){
        return NULL;
    }
#endif

	topic->domain = SDDS_DOMAIN;
	topic->id = SDDS_TOPIC;
	topic->Data_cpy = TopicMarshalling_$(topic.c_name:)_cpy;

.   for topic.config
.       if config.type = "qos_reliability"
#ifdef SDDS_HAS_QOS_RELIABILITY
topic->seqNrBitSize = $(project.qos_reliability_biggest_seqNr_bitsize:);
topic->reliabilityKind = $(topic.qos_reliability_kind:);
.           if topic.qos_reliability_kind = "2"
topic->confirmationtype = $(topic.qos_reliability_confirmationtype:);
topic->max_blocking_time = $(topic.qos_reliability_max_blocking_time:);
.           endif
#endif
.       endif
.   endfor

	return topic;
}

rc_t TopicMarshalling_$(topic.c_name:)_cpy(Data dest, Data source)
{
	memcpy(dest, source, sizeof($(topic.c_name:)));

	return SDDS_RT_OK;
}

rc_t TopicMarshalling_$(topic.c_name:)_encode(NetBuffRef_t* buffer, Data data, size_t* size)
{
	*size = 0;

	$(topic.c_name:)* real_data = ($(topic.c_name:)*) data;

	byte_t* start = buffer->buff_start + buffer->curPos + 1;

	int maxSize = 0;
.   for topic.attribute
    maxSize += sizeof(real_data->$(attribute.name:c));

.   endfor

	if ((buffer->curPos + maxSize + 1) >= SDDS_NET_MAX_BUF_SIZE) {
		return SDDS_RT_FAIL;
	}

.   for topic.attribute
.       if attribute.enc_type = "string"
    Marshalling_enc_$(attribute.enc_type)(start + *size, real_data->$(attribute.name:c), $(attribute.size));
.       else
    Marshalling_enc_$(attribute.enc_type)(start + *size, &real_data->$(attribute.name:c));
.       endif
    *size += sizeof(real_data->$(attribute.name:c));

.   endfor

	return SDDS_RT_OK;
}

rc_t TopicMarshalling_$(topic.c_name:)_decode(NetBuffRef_t* buffer, Data data, size_t* size)
{
	if (*size != $(topic.size))
		Log_warn ("size mismatch is %zu should be $(size)\\n", *size);

	*size = 0;

	byte_t* start = buffer->buff_start + buffer->curPos;

	$(topic.c_name:)* real_data = ($(topic.c_name:)*) data;

.   for topic.attribute
.       if attribute.enc_type = "string"
    Marshalling_dec_$(attribute.enc_type)(start + *size, real_data->$(attribute.name:c), $(attribute.size));
.       else
    Marshalling_dec_$(attribute.enc_type)(start + *size, &real_data->$(attribute.name:c));
.       endif
    *size += sizeof(real_data->$(attribute.name:c));

.   endfor

	return SDDS_RT_OK;
}
/*
$(project.GENERATED_WARNING_HEADER:)
*/
.else
// Generate stub's for the autobest client
#ifdef SDDS_TOPIC_HAS_PUB
DDS_ReturnCode_t DDS_$(topic.c_name:)DataReader_take_next_sample(
    DDS_DataReader self,
    $(topic.c_name:)** data_values,
    DDS_SampleInfo* sample_info
){
    unsigned int err;
    unsigned long recv_arg;
    // setting up the shm...
    g_shm_$(project.name:c)->$(topic.name:c)_seg.type = 0;
#ifdef FEATURE_SDDS_TRACING_ENABLED
#ifdef FEATURE_SDDS_TRACING_RECV_ISOLATED
#ifdef FEATURE_SDDS_TRACING_RPC_CALL
    Trace_point(SDDS_TRACE_EVENT_RPC_CALL);
#endif
#endif
#endif
    err = sys_rpc_call(CFG_RPC_rpc_sdds_$(project.name:c),DDS_$(topic.NAME)_READER_ID,-1, &recv_arg);
    assert(err ==  E_OK);
    $(topic.c_name:)* addr = *data_values;
    *addr = g_shm_$(project.name:c)->$(topic.name:c)_seg.data;
    return (DDS_ReturnCode_t) recv_arg;
}
#endif

#ifdef SDDS_TOPIC_HAS_SUB
DDS_ReturnCode_t DDS_$(topic.c_name:)DataWriter_write(
    DDS_DataWriter _this,
    const $(topic.c_name:)* instance_data,
    const DDS_InstanceHandle_t  handle

){
    g_shm_$(project.name:c)->$(topic.name:c)_seg.type = 1;
    memcpy(&g_shm_$(project.name:c)->$(topic.name:c)_seg.data, instance_data, sizeof($(topic.c_name:)));
    unsigned int err;
    unsigned long recv_arg;
#ifdef FEATURE_SDDS_TRACING_ENABLED
#ifdef FEATURE_SDDS_TRACING_SEND_ISOLATED
#ifdef FEATURE_SDDS_TRACING_RPC_CALL
    Trace_point(SDDS_TRACE_EVENT_RPC_CALL);
#endif
#endif
#endif
    err = sys_rpc_call(CFG_RPC_rpc_sdds_$(project.name:c), DDS_$(topic.NAME)_WRITER_ID,-1, &recv_arg);
    assert(err ==  E_OK);
    return (DDS_ReturnCode_t) recv_arg;
}
#endif
.endif
.   close
.endfor
